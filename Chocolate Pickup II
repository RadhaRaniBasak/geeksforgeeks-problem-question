class Solution {
    public int chocolatePickup(int[][] mat) {
        int n = mat.length;
        
        if (mat[0][0] == -1 || mat[n-1][n-1] == -1) {
            return 0;
        }
        
        int[][][] dp = new int[n][n][n];
        
        for (int i1 = 0; i1 < n; i1++)
            for (int j1 = 0; j1 < n; j1++)
                for (int i2 = 0; i2 < n; i2++)
                    dp[i1][j1][i2] = Integer.MIN_VALUE;
        
        dp[0][0][0] = mat[0][0];
        
        for (int i1 = 0; i1 < n; i1++) {
            for (int j1 = 0; j1 < n; j1++) {
                for (int i2 = 0; i2 < n; i2++) {
                    int j2 = i1 + j1 - i2;
                    
                    if (j2 < 0 || j2 >= n) continue;
                    
                    if (mat[i1][j1] == -1 || mat[i2][j2] == -1) continue;
                    
                    if (dp[i1][j1][i2] == Integer.MIN_VALUE) continue;
                    
                    int current = dp[i1][j1][i2];
                    
                    if (j1 + 1 < n && j2 + 1 < n && mat[i1][j1+1] != -1 && mat[i2][j2+1] != -1) {
                        int val = mat[i1][j1+1];
                        if (i1 != i2 || j1+1 != j2+1) val += mat[i2][j2+1];
                        dp[i1][j1+1][i2] = Math.max(dp[i1][j1+1][i2], current + val);
                    }
                    
                    if (j1 + 1 < n && i2 + 1 < n && mat[i1][j1+1] != -1 && mat[i2+1][j2] != -1) {
                        int val = mat[i1][j1+1];
                        if (i1 != i2+1 || j1+1 != j2) val += mat[i2+1][j2];
                        dp[i1][j1+1][i2+1] = Math.max(dp[i1][j1+1][i2+1], current + val);
                    }
                    
                    if (i1 + 1 < n && j2 + 1 < n && mat[i1+1][j1] != -1 && mat[i2][j2+1] != -1) {
                        int val = mat[i1+1][j1];
                        if (i1+1 != i2 || j1 != j2+1) val += mat[i2][j2+1];
                        dp[i1+1][j1][i2] = Math.max(dp[i1+1][j1][i2], current + val);
                    }
                    
                    if (i1 + 1 < n && i2 + 1 < n && mat[i1+1][j1] != -1 && mat[i2+1][j2] != -1) {
                        int val = mat[i1+1][j1];
                        if (i1+1 != i2+1 || j1 != j2) val += mat[i2+1][j2];
                        dp[i1+1][j1][i2+1] = Math.max(dp[i1+1][j1][i2+1], current + val);
                    }
                }
            }
        }
        
        return Math.max(0, dp[n-1][n-1][n-1]);
    }
}
